My project code can be found here: https://github.com/Loonride/elm-chat-room

In this project, I created a live chat room with WebSockets that uses Elm logic as much as possible both on the server and client, including some Elm data structures, encoders, and decoders that are shared between the server and client. I used a minimal JavaScript WebSocket client to call the Elm client logic via ports, and I did the same thing on the server using a Node.js WebSocket server. Note that I do have a good amount of experience with JavaScript and Node.js, so these elements were not a learning experience for me, but designing functional server and client logic with Elm was a completely new experience (which is why I aimed to keep the JavaScript code as minimal as possible).

I started the project off by searching for Elm WebSocket libraries. I discovered during this search that Elm doesn't have any built-in HTTP server networking, so the next best option is to make a server with JavaScript using Node.js and utilize Elm logic via ports. This is the design that the first library relied on which I tried using (https://github.com/billstclair/elm-websocket-framework-server). This library didn't fit my needs too well, but the knowledge I gained from trying to use this library made me realize that I could set up my own Elm ports and call those directly from my Node.js code without using an additional Elm library.

All that I had to do in my JavaScript server code was to listen for connections and messages, then pass them along to the Elm input and output ports as JSON strings to get decoded. I also listened on the output Elm port for messages, as this would indicate outgoing messages to WebSocket clients that had to be sent. The client JavaScript for the browser was even more straightforward. All I had to do was call the Elm input port for incoming WebSocket messages, and send messages to the server when something came from Elm on the output port.

I thought carefully about my data structures and JSON encoders/decoders so that I could share as much logic as possible between the Elm server and client. I decided that the server and client would both need identical State data structures that contain a dict of users and a list of recent messages. I designed encoders and decoders for this State structure and its elements so that when the state is updated on the authoritative server, it can be encoded on the server, broadcasted over WebSockets to all users, then decoded on the clients and updated for the users.

I learned that Elm can be a powerful tool for designing elegant and type-safe networking logic. At first, I was worried that Elm would simply be a burden to the project and that the time put into it would outweigh the benefits. I was wrong, as I discovered that Elm forced me to think carefully from the start about how to save the chat state as a data structure and how to set up my other data structures. Without this, I might have gone ahead with a poorly designed setup, then realized later that I needed to change all of my data structures. Passing data between ports from JavaScript to Elm was a constant reminder that I needed to be as conservative as possible about the data I was sending over the network, as unneeded data is simply a waste.

There are a few elements that I would've added with more time. The first is that whenever a new user joins or a new message is sent, all users are sent the entire state (full dict of users and list of messages). This is inefficient, as all that most users need (aside from a new user) is the new information, like a new message or new user. My design has the capability to implement this, but I chose not to for the sake of making a useable product rather than emphasizing full network efficiency. A couple other features that I would like to add are chat filters to prevent long messages/nicknames or special characters, and a color indicator to show users which messages they sent.
